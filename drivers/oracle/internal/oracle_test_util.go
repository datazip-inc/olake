package driver

import (
	"context"
	"fmt"
	"testing"
	"time"

	"github.com/apache/arrow-go/v18/arrow"
	"github.com/datazip-inc/olake/utils"
	"github.com/jmoiron/sqlx"
	_ "github.com/sijms/go-ora/v2"
	"github.com/stretchr/testify/require"
)

func ExecuteQuery(ctx context.Context, t *testing.T, streams []string, operation string, fileConfig bool) {
	t.Helper()

	var connStr string
	if fileConfig {
		var config Config
		utils.UnmarshalFile("./testdata/source.json", &config, false)
		connStr = config.connectionString()
	} else {
		connStr = "oracle://myuser:secret1234@localhost:1521/orcl"
	}

	db, err := sqlx.ConnectContext(ctx, "oracle", connStr)
	require.NoError(t, err, "failed to connect to oracle")
	defer func() {
		require.NoError(t, db.Close())
	}()

	// integration test uses only one stream for testing
	integrationTestTable := streams[0]
	var query string

	switch operation {
	case "create":
		// Oracle 23c supports boolean
		// Using generic types that map to what we support
		query = fmt.Sprintf(`
			CREATE TABLE %s (
				id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
				col_bigint NUMBER(19, 0),
				col_char CHAR(1),
				col_character CHAR(10),
				col_varchar2 VARCHAR2(50),
				col_date DATE,
				col_decimal NUMBER(10, 2),
				col_double_precision BINARY_DOUBLE,
				col_float BINARY_FLOAT,
				col_int NUMBER(9, 0),
				col_smallint NUMBER(5, 0),
				col_integer INTEGER,
				col_clob CLOB,
				col_nclob NCLOB,
				col_blob BLOB,
				col_timestamp TIMESTAMP,
				col_timestamptz TIMESTAMP WITH TIME ZONE
			)`, integrationTestTable)

	case "drop":
		query = fmt.Sprintf(`
			BEGIN
				EXECUTE IMMEDIATE 'DROP TABLE %s';
			EXCEPTION
				WHEN OTHERS THEN
					IF SQLCODE != -942 THEN
						RAISE;
					END IF;
			END;`, integrationTestTable)

	case "clean":
		query = fmt.Sprintf("TRUNCATE TABLE %s", integrationTestTable)

	case "add":
		insertTestData(t, ctx, db, integrationTestTable)
		return

	case "insert":
		query = fmt.Sprintf(`
			INSERT INTO %s (
				col_bigint, col_char, col_character,
				col_varchar2, col_date, col_decimal,
				col_double_precision, col_float, col_int, col_smallint,
				col_integer, col_clob, col_nclob, col_timestamp, col_timestamptz
			) VALUES (
				123456789012345, 'c', 'char_val',
				'varchar_val', TO_DATE('2023-01-01', 'YYYY-MM-DD'), 123.45,
				123.456789, 123.45, 123, 123, 12345,
				'sample text', 'sample nclob',
				TIMESTAMP '2023-01-01 12:00:00',
				TIMESTAMP '2023-01-01 12:00:00+00:00'
			)`, integrationTestTable)

	case "update":
		query = fmt.Sprintf(`
			UPDATE %s SET
				col_bigint = 123456789012340,
				col_char = 'd',
				col_character = 'updated__',
				col_varchar2 = 'updated val',
				col_date = TO_DATE('2024-07-01', 'YYYY-MM-DD'),
				col_decimal = 543.21,
				col_double_precision = 987.654321,
				col_float = 543.21,
				col_int = 321,
				col_smallint = 321,
				col_integer = 54321,
				col_clob = 'updated text',
				col_nclob = 'updated nclob',
				col_timestamp = TIMESTAMP '2024-07-01 15:30:00',
				col_timestamptz = TIMESTAMP '2024-07-01 15:30:00+00:00'
			WHERE id = 1`, integrationTestTable)

	case "delete":
		query = fmt.Sprintf("DELETE FROM %s WHERE id = 1", integrationTestTable)

	case "evolve-schema":
		// Oracle supports altering columns
		query = fmt.Sprintf(`ALTER TABLE %s MODIFY (col_int NUMBER(19,0), col_float BINARY_DOUBLE)`, integrationTestTable)

	default:
		// Oracle doesn't support setup_cdc or bulk_cdc_data_insert as requested
		// if operation == "setup_cdc" || operation == "bulk_cdc_data_insert" {
		// 	return
		// }
		t.Fatalf("Unsupported operation: %s", operation)
	}

	_, err = db.ExecContext(ctx, query)
	require.NoError(t, err, "Failed to execute %s operation", operation)
}

func insertTestData(t *testing.T, ctx context.Context, db *sqlx.DB, tableName string) {
	t.Helper()

	for i := 1; i <= 5; i++ {
		query := fmt.Sprintf(`
		INSERT INTO %s (
			col_bigint, col_char, col_character,
			col_varchar2, col_date, col_decimal,
			col_double_precision, col_float, col_int, col_smallint,
			col_integer, col_clob, col_nclob, col_timestamp, col_timestamptz
		) VALUES (
			123456789012345, 'c', 'char_val',
			'varchar_val', TO_DATE('2023-01-01', 'YYYY-MM-DD'), 123.45,
			123.456789, 123.45, 123, 123, 12345,
			'sample text', 'sample nclob',
			TIMESTAMP '2023-01-01 12:00:00',
			TIMESTAMP '2023-01-01 12:00:00+00:00'
		)`, tableName)

		_, err := db.ExecContext(ctx, query)
		require.NoError(t, err, "Failed to insert test data")
	}
}

var ExpectedOracleData = map[string]interface{}{
	"col_bigint":           int64(123456789012345),
	"col_char":             "c",
	"col_character":        "char_val  ", // Oracle CHAR is fixed width, padded with spaces
	"col_varchar2":         "varchar_val",
	"col_date":             arrow.Timestamp(time.Date(2023, 1, 1, 0, 0, 0, 0, time.UTC).UnixNano() / int64(time.Microsecond)),
	"col_decimal":          float64(123.45),
	"col_double_precision": 123.456789,
	"col_float":            float32(123.45),
	"col_int":              int32(123),
	"col_smallint":         int32(123),
	"col_integer":          int64(12345),
	"col_clob":             "sample text",
	"col_nclob":            "sample nclob",
	"col_timestamp":        arrow.Timestamp(time.Date(2023, 1, 1, 12, 0, 0, 0, time.UTC).UnixNano() / int64(time.Microsecond)),
	"col_timestamptz":      arrow.Timestamp(time.Date(2023, 1, 1, 12, 0, 0, 0, time.UTC).UnixNano() / int64(time.Microsecond)),
}

var ExpectedUpdatedOracleData = map[string]interface{}{
	"col_bigint":           int64(123456789012340),
	"col_char":             "d",
	"col_character":        "updated__ ",
	"col_varchar2":         "updated val",
	"col_date":             arrow.Timestamp(time.Date(2024, 7, 1, 0, 0, 0, 0, time.UTC).UnixNano() / int64(time.Microsecond)),
	"col_decimal":          float64(543.21),
	"col_double_precision": 987.654321,
	"col_float":            float64(543.21), // Evolved to BINARY_DOUBLE which maps to Float64? Or explicitly Float64
	"col_int":              int64(321),      // Evolved to NUMBER(19,0) which maps to Int64
	"col_smallint":         int32(321),
	"col_integer":          int64(54321),
	"col_clob":             "updated text",
	"col_nclob":            "updated nclob",
	"col_timestamp":        arrow.Timestamp(time.Date(2024, 7, 1, 15, 30, 0, 0, time.UTC).UnixNano() / int64(time.Microsecond)),
	"col_timestamptz":      arrow.Timestamp(time.Date(2024, 7, 1, 15, 30, 0, 0, time.UTC).UnixNano() / int64(time.Microsecond)),
}

var OracleToDestinationSchema = map[string]string{
	"id":                   "bigint", // identity column
	"col_bigint":           "bigint",
	"col_char":             "string",
	"col_character":        "string",
	"col_varchar2":         "string",
	"col_date":             "timestamp",
	"col_decimal":          "double",
	"col_double_precision": "double",
	"col_float":            "float",
	"col_int":              "int",
	"col_smallint":         "int",
	"col_integer":          "bigint",
	"col_clob":             "string",
	"col_nclob":            "string",
	"col_blob":             "string",
	"col_timestamp":        "timestamp",
	"col_timestamptz":      "timestamp",
}

var UpdatedOracleToDestinationSchema = map[string]string{
	"id":                   "bigint",
	"col_bigint":           "bigint",
	"col_char":             "string",
	"col_character":        "string",
	"col_varchar2":         "string",
	"col_date":             "timestamp",
	"col_decimal":          "double",
	"col_double_precision": "double",
	"col_float":            "double", // Evolved
	"col_int":              "bigint", // Evolved
	"col_smallint":         "int",
	"col_integer":          "bigint",
	"col_clob":             "string",
	"col_nclob":            "string",
	"col_blob":             "string",
	"col_timestamp":        "timestamp",
	"col_timestamptz":      "timestamp",
}
